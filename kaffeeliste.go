package main

import (
	"fmt"
	"os"
	"strconv"

	"github.com/akamensky/argparse"
	"github.com/common-nighthawk/go-figure"
	"github.com/olekukonko/tablewriter"
)

var (
	// Kopfzeile
	headline *string

	// Schrift der Kopfzeile
	headlineFont *string

	// Pfad zur Konfigurationsdatei
	configFilePath *string

	// Breite einer Spalte
	width *int

	// Anzahl der Spalten
	cols *int

	// Anzahl der Zeilen pro Name
	rows *int

	// Character für eine Kaffee-Position
	character *string

	// Breite der Namensspalte
	widthNameCol *int

	// Kaffeetrinker-Namen
	names *[]string

	// Soll der Tabellenrahmen angezeigt werden?
	showBorder *bool

	// Text für jede Row in einer Column
	colRowText string

	// Text im Footer
	footerText string = "Generated by github.com/nullpointerio/Kaffeeliste"
)

func main() {
	parseArguments()
	printHeader()
	printTable()
	printFooter()
}

// Liest die command-line-Parameter ein.
func parseArguments() {
	// Parser
	parser := argparse.NewParser("Kaffeeliste", "Generates a list containing all coffee-trinkers to make a tick for every coffee")

	// Parameter
	headline = parser.String("", "headline", &argparse.Options{Required: false, Default: "Kaffeeliste", Help: "Headline"})
	headlineFont = parser.String("", "headlinefont", &argparse.Options{Required: false, Default: "univers", Help: "Font from https://github.com/common-nighthawk/go-figure"})
	configFilePath = parser.String("f", "file", &argparse.Options{Required: false, Help: "path of configuration file"})
	character = parser.String("", "char", &argparse.Options{Required: false, Default: "C", Help: "character for each position"})
	width = parser.Int("w", "width", &argparse.Options{Required: false, Default: 5, Help: "col width (characters per col)"})
	widthNameCol = parser.Int("", "widthnamecol", &argparse.Options{Required: false, Default: 18, Help: "width of the name-column"})
	cols = parser.Int("c", "cols", &argparse.Options{Required: false, Default: 7, Help: "number of cols"})
	rows = parser.Int("r", "rows", &argparse.Options{Required: false, Default: 5, Help: "number of rows per name"})
	names = parser.StringList("n", "name", &argparse.Options{Required: true, Help: "names of the coffee-trinkers"})
	showBorder = parser.Flag("b", "border", &argparse.Options{Required: false, Default: true, Help: "show border"})

	// Im Fehlerfall Hilfe ausgeben und Programm verlassen
	err := parser.Parse(os.Args)
	if err != nil {
		fmt.Print(parser.Usage(err))
		os.Exit(1)
	}

	generateColRowText()
}

// Schreibt den Header auf stdout.
func printHeader() {
	myFigure := figure.NewColorFigure(*headline, *headlineFont, "green", true)
	myFigure.Print()
}

// Schreibt die Tabelle auf stdout.
func printTable() {
	table := tablewriter.NewWriter(os.Stdout)
	table.SetHeader(generateColHeader())
	table.SetAutoMergeCellsByColumnIndex([]int{0})
	table.SetRowLine(false)
	table.SetColMinWidth(0, *widthNameCol)
	table.AppendBulk(generateDataForTableWriter())
	table.SetBorder(*showBorder)
	table.Render()
}

// Generiert die Spalten-Header
func generateColHeader() []string {
	headers := []string{"Name"}
	for i := 0; i < *cols; i++ {
		headers = append(headers, strconv.FormatInt(int64(i+1), 10))
	}
	return headers
}

// Generiert die Datenstruktur für die Tabelle
func generateDataForTableWriter() [][]string {
	data := [][]string{}

	// Eintrag für jeden Namen
	for _, name := range *names {

		// Für jeden Namen die Anzahl der Zeilen generieren
		for rowPosition := 0; rowPosition < *rows; rowPosition++ {
			//bean := html.UnescapeString("&#" + strconv.Itoa())
			newCol := []string{name}

			// Anzahl der Spalten generieren
			for colPosition := 0; colPosition < *cols; colPosition++ {
				newCol = append(newCol, colRowText)
			}
			data = append(data, newCol)
		}

		// Leere Zeile einfügen
		newCol := []string{name}
		for colPosition := 0; colPosition < *cols; colPosition++ {
			newCol = append(newCol, "")
		}
		data = append(data, newCol)
	}
	return data
}

func printFooter() {
	footerWidth := *widthNameCol + (len(colRowText) * *cols) + (3 * *cols)

	table := tablewriter.NewWriter(os.Stdout)
	table.SetBorder(true)
	table.SetColMinWidth(0, footerWidth)
	table.SetColWidth(footerWidth)
	table.Append([]string{footerText})
	table.SetAlignment(tablewriter.ALIGN_CENTER)
	table.Render()
}

// Generiert den Text für eine Zeile in einer Spalte
func generateColRowText() {
	for charPosition := 0; charPosition < *width; charPosition++ {
		colRowText = colRowText + *character
		if charPosition < *width-1 {
			colRowText = colRowText + " "
		}
	}
}
